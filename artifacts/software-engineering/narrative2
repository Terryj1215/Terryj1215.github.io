Milestone Three: Narrative (Enhancement Two) – Algorithms and Data StructureArtifact DescriptionThe artifact is the Location Tracking Module within the GuardianPath Safety Dashboard, a C++ application utilizing the Qt Framework and QML (Qt Modeling Language). Originally developed as a static UI/UX mockup in Module One—derived from foundational concepts in CS-319—it has been significantly enhanced into a dynamic geospatial engine. The current version features an interactive OpenStreetMap (OSM) interface, an asynchronous Geocoding search system, and real-time geofence validation.Justification for InclusionI selected this artifact for my ePortfolio because it demonstrates the critical transition from "static data display" to "algorithmic data processing." By implementing complex mathematical models to handle geographic data, I have showcased several industry-standard skills in Algorithms and Data Structure:Algorithmic Implementation (Haversine Formula): I developed a backend algorithm using the Haversine formula to calculate the great-circle distance between two points on a sphere ($Latitude, Longitude$). This demonstrates my ability to implement complex mathematical theory into functional code to solve real-world proximity problems.Asynchronous Data Structures: I integrated a GeocodeModel to handle address searching. This required managing asynchronous data structures that fetch and process geographic coordinates without interrupting the main application thread, ensuring a high-performance user experience.Cross-Platform Data Integration: By bridging C++ logic with a QML visual layer, I managed data synchronization across different runtime environments, ensuring that user-defined safety parameters are reflected instantly in the UI.Technical Refinement & Concrete OutcomesA major focus of this enhancement was solving specific functional challenges to improve the software's reliability and precision:Improved Navigation and Input Validation: I replaced manual, error-prone coordinate entry with an interactive "Search and Click" interface. This concrete outcome reduced input latency and improved the accuracy of the "Safe Zone" establishment by allowing users to search for human-readable addresses.Dynamic Geofence Feedback: I implemented a real-time boundary-checking algorithm. When the "Current Location" coordinates change, the system instantly recalculates the distance and updates the UI (Green for Safe, Red for Alarm). This provides the caregiver with immediate, actionable data.Dependency Troubleshooting: During integration, I encountered and resolved a "Blank Map" issue caused by API authentication requirements. By configuring custom PluginParameter settings to handle osm.useragent data, I demonstrated my ability to troubleshoot and resolve issues within third-party library dependencies.Course Outcome CoverageThis enhancement specifically meets several Computer Science program outcomes:Outcome 3: I designed and evaluated a computing solution that uses algorithmic principles (Haversine/Geocoding) to solve the problem of real-time proximity monitoring, managing the trade-offs between precision and processing speed.Outcome 4: By utilizing the Qt Location and Positioning modules in conjunction with standard C++ class structures, I implemented a solution using well-founded techniques that deliver industry-specific value through organized code.Reflection on the ProcessThe process of enhancing this artifact provided a deep dive into the complexities of Geospatial Computing. One of the most significant challenges was the coordinate transformation—mapping a 2D pixel click on a screen to a 3D geographic coordinate on the globe.I learned that while software architecture (Enhancement One) provides the "skeleton" of a program, algorithms provide the "intelligence." Developing the Haversine logic was a pivotal moment where I saw how mathematical theory directly translates into a life-safety feature. Facing the challenges of implementation—such as bypassing API key requirements and ensuring the radius slider accurately updated the visual map circle—allowed me to bridge the gap between high-level UI design and backend systems integration.
